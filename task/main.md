# Hotly App - Main Task Structure

## 0. 공통 기본 세팅 (Common Setup)

### 0-1. 개발환경 및 프로젝트 구조 설정
- **목표**: 일관된 개발 환경과 코드 품질 보장을 위한 기본 인프라 구축
- **완료 정의 (DoD)**:
  - Backend FastAPI 프로젝트 구조 완성 (Poetry + 가상환경)
  - 코드 품질 도구 설정 (black, isort, flake8, mypy)
  - Pre-commit hooks 및 GitHub Actions CI/CD 파이프라인 구축
  - 테스트 커버리지 80% 이상 유지 설정
  - Docker 개발 환경 및 docker-compose.yml 구성
- **수용 기준**:
  - Given 새로운 개발자가 프로젝트를 클론함, When `make setup` 실행함, Then 5분 내에 개발 환경이 구축됨
  - Given 코드를 커밋함, When pre-commit hook이 실행됨, Then 모든 린트/포맷 검사를 통과함
  - Given `docker-compose up`을 실행함, When 서비스가 시작됨, Then 헬스체크 엔드포인트가 200 응답함
- **하위 작업**:
  - 0-1-1. FastAPI 프로젝트 구조 생성 및 Poetry 설정
    - **상세**: `app/main.py`, `app/api/`, `app/core/`, `app/models/`, `app/schemas/`, `app/services/`, `app/db/`, `tests/` 디렉터리 구조
    - **결과물**: `pyproject.toml`, 가상환경 설정, 개발 의존성 패키지 설치
    - **테스트**: Poetry 명령어로 패키지 설치 및 가상환경 활성화 확인
  - 0-1-2. 코드 품질 도구 설정 (black, isort, flake8, mypy)
    - **상세**: `pyproject.toml`에 각 도구별 설정 추가, VS Code 설정 파일
    - **결과물**: `.flake8`, `mypy.ini`, VS Code `settings.json`
    - **테스트**: 의도적 포맷 오류 코드로 각 도구 동작 확인
  - 0-1-3. Pre-commit hooks 설정
    - **상세**: `.pre-commit-config.yaml` 작성, black/isort/flake8/mypy 훅 설정
    - **결과물**: 커밋 시 자동 코드 품질 검사 실행
    - **테스트**: 의도적 오류 코드 커밋하여 훅 차단 확인
  - 0-1-4. GitHub Actions CI/CD 파이프라인 구성
    - **상세**: `.github/workflows/ci.yml`, 테스트/린트/빌드/배포 단계
    - **결과물**: PR 생성시 자동 CI 실행, 마스터 브랜치 머지시 배포
    - **테스트**: 의도적 테스트 실패로 CI 차단 확인
  - 0-1-5. 테스트 프레임워크 및 커버리지 설정
    - **상세**: pytest, pytest-cov, pytest-asyncio 설정
    - **결과물**: `pytest.ini`, 커버리지 리포트 HTML 생성
    - **테스트**: 샘플 테스트 실행하여 80% 커버리지 달성 확인
  - 0-1-6. Docker 개발 환경 설정
    - **상세**: `Dockerfile`, `docker-compose.yml` (FastAPI + PostgreSQL + Redis)
    - **결과물**: 원클릭 개발 환경 구축
    - **테스트**: `docker-compose up`으로 전체 스택 실행 확인
- **참고 문서**: `prd/main.md`, `trd/main.md` (개발 환경 요구사항), `backend_reference/` (기존 구조 참고)

### 0-2. 공통 데이터베이스 및 캐시 설정
- **목표**: PostgreSQL과 Redis를 이용한 확장 가능한 데이터베이스 환경 구축
- **완료 정의 (DoD)**:
  - PostgreSQL 연결 설정 및 기본 테이블 스키마 정의
  - Redis 연결 설정 및 키 네임스페이스 정의
  - Alembic migrations 시스템 구축
  - 연결 상태 헬스체크 엔드포인트 구현
  - 데이터베이스 인덱스 최적화 및 성능 튜닝
- **수용 기준**:
  - Given 애플리케이션이 시작됨, When 데이터베이스 연결을 확인함, Then 2초 내에 연결 상태 응답
  - Given 스키마 변경이 필요함, When 마이그레이션을 실행함, Then 데이터 무결성을 유지하며 스키마 업데이트
  - Given 1000개 장소 데이터가 있음, When 검색 쿼리를 실행함, Then 100ms 내에 결과 반환
- **하위 작업**:
  - 0-2-1. PostgreSQL 연결 설정 및 모델 정의
    - **상세**: asyncpg 비동기 드라이버, SQLAlchemy ORM 설정, 연결 풀 최적화
    - **결과물**: `app/db/postgresql.py`, `app/models/` SQLAlchemy 모델들
    - **API**: `GET /health/db` - PostgreSQL 연결 상태 확인
    - **테스트**: 연결 실패 시나리오, 트랜잭션 롤백, 타임아웃 처리
  - 0-2-2. Redis 연결 설정 및 키 네임스페이스 정의
    - **상세**: aioredis 설정, 클러스터 지원, 키 네이밍 컨벤션 `hotly:{service}:{key}`
    - **결과물**: `app/db/redis.py`, 캐시 매니저 클래스
    - **API**: `GET /health/cache` - Redis 연결 상태 확인
    - **테스트**: Redis 장애 시 graceful degradation 확인
  - 0-2-3. Alembic 마이그레이션 시스템 구축
    - **상세**: Alembic 기반 스키마 버전 관리, 자동 마이그레이션 생성
    - **결과물**: `alembic/versions/`, `alembic.ini`, 마이그레이션 실행 스크립트
    - **API**: `POST /admin/migrate` - 마이그레이션 실행 (관리자 전용)
    - **테스트**: 마이그레이션 up/down, 스키마 변경, 데이터 보존
  - 0-2-4. 헬스체크 엔드포인트 구현
    - **상세**: 데이터베이스, 캐시, 외부 서비스 상태 종합 확인
    - **결과물**: `app/api/health.py`, Kubernetes 레디니스 프로브 지원
    - **API**: `GET /health`, `GET /health/detailed`
    - **테스트**: 각 서비스별 장애 시나리오 시뮬레이션
  - 0-2-5. PostgreSQL 인덱스 및 확장 설정
    - **상세**: B-tree/GIN/GiST 인덱스, PostGIS 확장, pg_trgm 유사도 검색
    - **결과물**: 인덱스 생성 마이그레이션, PostGIS 설정, 성능 모니터링
    - **API**: `GET /admin/indexes` - 인덱스 상태 확인
    - **테스트**: 공간 쿼리, 전문 검색, 인덱스 성능, EXPLAIN ANALYZE
  - 0-2-6. 데이터베이스 설정 테스트 코드 작성
    - **상세**: 연결 테스트, 기본 CRUD 테스트, 트랜잭션 테스트
    - **결과물**: `tests/test_database.py`, 통합 테스트 시나리오
    - **테스트**: DB 장애 복구, 연결 풀 exhaustion 처리
- **참고 문서**: `trd/02-place-management.md` (데이터베이스 설계), `trd/11-cache-performance.md` (캐시 전략), `backend_reference/app/db/` (기존 PostgreSQL 설정)

### 0-3. 공통 인증 및 보안 설정
- **목표**: JWT 인증, 환경변수 관리, API 보안 기본 설정
- **완료 정의 (DoD)**:
  - JWT 토큰 생성/검증 시스템 구축
  - 환경변수 기반 설정 관리 시스템
  - API 레이트 리미팅 및 입력 검증 미들웨어
  - 보안 헤더 및 CORS 설정
- **수용 기준**:
  - Given 유효한 JWT 토큰으로 요청함, When API를 호출함, Then 인증된 사용자로 처리됨
  - Given 초당 100개 요청을 보냄, When 레이트 리미트에 도달함, Then 429 상태코드 반환
- **하위 작업**:
  - 0-3-1. JWT 인증 시스템 구현
  - 0-3-2. 환경변수 기반 설정 관리 (Pydantic Settings)
  - 0-3-3. API 레이트 리미팅 미들웨어
  - 0-3-4. 입력 검증 및 보안 헤더 설정
  - 0-3-5. 인증/보안 테스트 코드 작성
- **참고 문서**: `prd/09-authentication.md`, `trd/09-authentication.md` (인증 요구사항)

## 1. 핵심 기능 개발 (Backend Focus)

### 1-1. SNS 링크 분석 백엔드 개발
- **목표**: Instagram, 블로그 등 SNS 링크를 분석하여 장소 정보를 추출하는 AI 기반 시스템 구축
- **완료 정의 (DoD)**:
  - URL 파싱 및 메타데이터 추출 API (30초 이내 응답)
  - Google Gemini AI 연동 서비스 (90% 이상 정확도)
  - 장소 정보 추출 및 저장 로직
  - Redis 기반 캐싱 시스템 (40% 이상 캐시 적중률)
  - 분석 결과 조회 API
  - Circuit Breaker 패턴으로 외부 서비스 장애 대응
  - 동시 분석 요청 100건/분 처리 가능
- **수용 기준**:
  - Given Instagram URL 입력, When 링크 분석 요청, Then 30초 이내 장소 정보 반환 (p90)
  - Given 중복 URL 요청, When 캐시 조회, Then 1초 이내 캐시된 결과 반환
  - Given AI 서비스 장애, When Circuit Breaker 활성화, Then 우아한 실패 처리 및 재시도 안내
- **하위 작업**:
  - 1-1-1. URL 링크 파싱 및 메타데이터 추출 서비스
    - **상세**: Playwright 기반 웹 스크래핑, Instagram/YouTube/네이버블로그 지원
    - **구현**: `app/services/content_extractor.py`, 플랫폼별 스크래퍼 클래스
    - **API**: `POST /api/v1/links/extract-content`
    - **데이터모델**: ContentData(url, title, description, images, text_content)
    - **에러처리**: UnsupportedPlatformError, ContentExtractionError
    - **테스트**: 각 플랫폼별 실제 URL 테스트, 타임아웃 처리, 봇 감지 회피
  - 1-1-2. Google Gemini AI 연동 및 프롬프트 엔지니어링
    - **상세**: Gemini Pro Vision 멀티모달 분석, 프롬프트 템플릿 관리
    - **구현**: `app/services/ai_analyzer.py`, 프롬프트 버전 관리
    - **API**: `POST /api/v1/ai/analyze-place`
    - **데이터모델**: GeminiRequest(content, images), GeminiResponse(places, confidence)
    - **에러처리**: AIAnalysisError, RateLimitError, 지수 백오프 재시도
    - **테스트**: Mock Gemini 응답, 다양한 콘텐츠 타입, 에러 시나리오
  - 1-1-3. 장소 정보 추출 및 구조화 로직
    - **상세**: AI 응답 파싱, 데이터 검증, 신뢰도 계산
    - **구현**: `app/services/place_extractor.py`, Pydantic 스키마 검증
    - **API**: 내부 서비스 (직접 API 노출 안함)
    - **데이터모델**: PlaceExtraction(place_name, address, category, confidence)
    - **에러처리**: ValidationError, 필수 필드 누락 처리
    - **테스트**: 다양한 AI 응답 형태, 신뢰도 경계값, 데이터 품질 검증
  - 1-1-4. Redis 캐싱 및 중복 방지 시스템
    - **상세**: URL 해시 기반 캐싱, 분산 락, TTL 관리
    - **구현**: `app/services/cache_manager.py`, 다계층 캐시 (L1: 로컬, L2: Redis)
    - **API**: 내부 서비스 (캐시 통계는 `/admin/cache-stats`에서 확인)
    - **데이터모델**: CacheEntry(data, ttl, created_at), CacheStats(hit_rate, miss_count)
    - **에러처리**: CacheConnectionError, graceful degradation
    - **테스트**: 캐시 적중/미적중 시나리오, TTL 만료, 분산 락 경합
  - 1-1-5. 링크 분석 API 엔드포인트 구현
    - **상세**: 비동기 분석 큐, 상태 조회, 웹훅 지원
    - **구현**: `app/api/v1/endpoints/link_analysis.py`
    - **API**:
      - `POST /api/v1/links/analyze` - 분석 요청
      - `GET /api/v1/analyses/{analysis_id}` - 결과 조회
      - `DELETE /api/v1/analyses/{analysis_id}` - 분석 취소
    - **데이터모델**: LinkAnalyzeRequest, AnalysisResponse, AnalysisStatus
    - **에러처리**: 400(잘못된 URL), 429(레이트 리미트), 503(서비스 장애)
    - **테스트**: E2E 분석 플로우, 동시 요청 처리, 레이트 리미팅
  - 1-1-6. SNS 링크 분석 종합 테스트 코드 작성
    - **상세**: TDD 기반 전체 플로우 테스트, 성능 테스트, 부하 테스트
    - **구현**: `tests/test_link_analysis.py`, `tests/performance/test_link_analysis_load.py`
    - **커버리지**: 전체 링크 분석 기능 85% 이상 (중요 기능은 95%)
    - **단위 테스트**: 각 서비스별 독립 테스트 (외부 의존성 목킹)
    - **통합 테스트**: E2E 분석 플로우 (URL 입력 → 결과 저장)
    - **성능 테스트**: 100개 동시 요청, 캐시 적중률, 메모리 사용량
    - **시나리오**: 정상 분석, 캐시 적중/미적중, AI 장애, 네트워크 장애
- **참고 문서**: `prd/01-sns-link-analysis.md` (요구사항), `trd/01-sns-link-analysis.md` (기술 설계)

### 1-2. 장소 관리 백엔드 개발
- **목표**: 사용자가 발견한 장소를 저장, 분류, 검색할 수 있는 백엔드 시스템 구축
- **완료 정의 (DoD)**:
  - 장소 CRUD API 구현 (p95 1초 이내 응답)
  - 중복 장소 방지 로직 (95% 정확도, 이름+주소+좌표 기반)
  - AI 기반 자동 카테고리 분류 (80% 이상 정확도)
  - 사용자 정의 태그 관리 및 자동완성
  - 지리적 검색 (2dsphere 인덱스, 50km 반경)
  - Elasticsearch 기반 전문 검색 (500ms 이내)
- **수용 기준**:
  - Given 사용자가 장소를 등록함, When 중복 검사를 실행함, Then 95% 정확도로 중복 감지
  - Given 장소 목록 요청, When 50km 반경 검색함, Then 거리순으로 20개씩 페이지네이션
  - Given 100개 장소 데이터, When 키워드 검색함, Then 500ms 내 관련도순 결과 반환
  - Given 태그 입력, When 자동완성 요청, Then 사용 빈도순 10개 태그 제안
- **하위 작업**:
  - 1-2-1. PostgreSQL 장소 스키마 및 인덱스 설계
    - **상세**: PostGIS 좌표, 사용자별 파티셔닝, 복합 인덱스 최적화
    - **구현**: `app/models/place.py`, SQLAlchemy ORM 모델
    - **스키마**: places 테이블 (user_id, place_id, name, coordinates, category, tags, status)
    - **인덱스**: GiST(coordinates), B-tree(user_id+category), GIN(name+address+tags)
    - **성능**: 지리 검색 50ms, 텍스트 검색 100ms, 필터링 50ms
    - **테스트**: 인덱스 성능 벤치마크, 쿼리 실행 계획 분석
  - 1-2-2. 장소 중복 방지 알고리즘 (이름+주소 정규화)
    - **상세**: 레벤슈타인 거리, 지리적 거리, 퍼지 매칭 조합
    - **구현**: `app/services/duplicate_detector.py`, 다단계 중복 검사
    - **알고리즘**: 1차(이름 정규화+유사도), 2차(주소 매칭), 3차(좌표 50m 반경)
    - **성능**: 중복 검사 200ms 이내, 정확도 95% 이상
    - **API**: `POST /api/v1/places/check-duplicate`
    - **테스트**: 정확/유사/다른 장소 시나리오, 성능 벤치마크
  - 1-2-3. AI 기반 자동 카테고리 분류 시스템
    - **상세**: scikit-learn RandomForest, TF-IDF 벡터화, 온라인 학습
    - **구현**: `app/services/place_classifier.py`, 모델 버전 관리
    - **모델**: TF-IDF + RandomForest (6개 카테고리 분류)
    - **성능**: 분류 시간 50ms, 정확도 80% 이상
    - **API**: `POST /api/v1/places/classify`
    - **테스트**: 카테고리별 분류 정확도, 신뢰도 임계값, 모델 업데이트
  - 1-2-4. 사용자 정의 태그 관리 및 자동완성
    - **상세**: 태그 정규화, 사용 통계, 자동완성 제안
    - **구현**: `app/services/tag_service.py`, Redis 기반 실시간 통계
    - **기능**: 태그 추가/삭제, 자동완성, 인기 태그 추천
    - **성능**: 자동완성 100ms, 태그 통계 실시간 업데이트
    - **API**: `GET /api/v1/tags/suggestions`, `POST /api/v1/places/{id}/tags`
    - **테스트**: 태그 정규화, 자동완성 정확도, 사용 통계 업데이트
  - 1-2-5. 장소 CRUD API 및 검색/필터 기능
    - **상세**: RESTful API, 페이지네이션, 정렬, 다중 필터
    - **구현**: `app/api/v1/endpoints/places.py`, FastAPI 라우터
    - **API**:
      - `POST /api/v1/places` - 장소 생성
      - `GET /api/v1/places` - 목록 조회 (필터/정렬/페이지네이션)
      - `GET /api/v1/places/{id}` - 상세 조회
      - `PUT /api/v1/places/{id}` - 정보 수정
      - `DELETE /api/v1/places/{id}` - 삭제
      - `PUT /api/v1/places/{id}/status` - 상태 변경
    - **성능**: CRUD 작업 p95 1초 이내
    - **테스트**: 전체 CRUD 플로우, 권한 검증, 입력 검증
  - 1-2-6. 지리적 검색 및 거리 계산 로직
    - **상세**: PostgreSQL PostGIS 확장, GeoPy 거리 계산
    - **구현**: `app/services/geo_service.py`, 지리 검색 최적화
    - **기능**: 반경 검색, 거리순 정렬, 지역별 클러스터링
    - **성능**: 지리 검색 100ms, 1000개 장소 대상 성능 유지
    - **API**: `GET /api/v1/places/nearby?lat={lat}&lng={lng}&radius={km}`
    - **테스트**: 다양한 반경/위치, 거리 계산 정확도, 경계값 테스트
  - 1-2-7. PostgreSQL 전문 검색 및 Elasticsearch 연동
    - **상세**: PostgreSQL full-text search, 한국어 형태소 분석기(nori), Elasticsearch 하이브리드 검색
    - **구현**: `app/services/search_service.py`, PostgreSQL tsvector 및 ES 인덱스 관리
    - **기능**: 전문 검색, 퍼지 매칭, 검색어 하이라이팅, 자동완성
    - **성능**: 검색 응답 500ms 이내, 자동완성 100ms
    - **API**: `GET /api/v1/places/search?q={query}&category={cat}&tags={tags}`
    - **테스트**: 검색 정확도, 한국어 검색, 복합 필터, 성능 테스트
  - 1-2-8. 장소 관리 종합 테스트 코드 작성
    - **상세**: 전체 플로우 통합 테스트, 성능 테스트, 부하 테스트
    - **구현**: `tests/test_place_management.py`, E2E 시나리오
    - **커버리지**: 전체 장소 관리 기능 80% 이상
    - **시나리오**: 생성→검색→수정→삭제, 중복 처리, 상태 전이
    - **성능**: 동시 사용자 100명, 메모리 누수 검사
- **참고 문서**: `prd/02-place-management.md` (요구사항), `trd/02-place-management.md` (기술 설계)

### 1-3. AI 기반 코스 추천 백엔드 개발
- **목표**: 사용자 취향 및 위치 기반으로 최적화된 데이트 코스를 AI가 추천하는 시스템
- **완료 정의 (DoD)**:
  - 사용자 취향 분석 70% 정확도 (피드백 기반 학습)
  - 실시간 위치 기반 코스 추천
  - 다양한 코스 타입 5개 이상 (로맨틱, 액티비티, 맛집 등)
- **수용 기준**:
  - Given 5개 이상 취향 데이터, When 코스 추천 요청, Then 3가지 이상 코스 타입 제공
  - Given 코스 추천 결과, When 실시간 위치 확인, Then Google Maps API 기반 경로 정보 제공
- **하위 작업**:
  - 1-3-1. 사용자 취향 분석 및 프로파일링 시스템
  - 1-3-2. 장소 간 실시간 위치 확인 및 거리 알고리즘
  - 1-3-3. AI 기반 코스 추천 엔진 및 타입 분류
  - 1-3-4. 추천 결과 API 및 사용자 피드백 수집
  - 1-3-5. 코스 추천 UI 연동 및 최적화 로직
  - 1-3-6. 코스 추천 테스트 코드 작성
- **참고 문서**: `prd/03-course-recommendation.md`, `trd/03-course-recommendation.md`

### 1-4. 지도 기반 시각화 백엔드 개발
- **목표**: 추천된 코스를 지도 위에 시각적으로 표현하고 사용자에게 직관적인 경로 제공
- **완료 정의 (DoD)**:
  - Kakao Map SDK 연동 완료
  - 지도 데이터 최적화로 100개 이상 마커 1초 내 렌더링
  - 코스 경로 표시 및 소요시간 계산 정확도
- **수용 기준**:
  - Given 50개 이상 장소 마커, When 지도 로딩/줌인함, Then 60fps 유지하며 데이터 표시
  - Given 코스 선택, When 경로 표시 요청, Then 2초 이내 경로 정보 표시
- **하위 작업**:
  - 1-4-1. Kakao Map SDK 연동 및 기본 지도 로딩
  - 1-4-2. 마커 클러스터링 및 지도 데이터 최적화
  - 1-4-3. 코스 경로 표시 및 인터랙션 구현
  - 1-4-4. 지도 상 장소 상세정보 팝업 및 액션
  - 1-4-5. 소요시간 및 거리 기반 지도 최적화
  - 1-4-6. 지도 시각화 테스트 코드 작성
- **참고 문서**: `prd/04-map-visualization.md`, `trd/04-map-visualization.md`

### 1-5. 코스 공유 및 저장 백엔드 개발
- **목표**: 완성된 코스를 다른 사용자에게 공유하고 즐겨찾기 할 수 있는 소셜 기능
- **완료 정의 (DoD)**:
  - 코스 링크 공유 및 소유권 저장 기능
  - 좋아요 및 댓글 시스템으로 사용자 상호작용 구현
  - 개인 저장 (즐겨찾기/위시리스트) 기능
- **수용 기준**:
  - Given 코스 공유 링크, When 외부에서 접근함, Then 즐겨찾기 없이 코스 정보 표시
  - Given 저장된 코스 목록, When 소유자가 삭제 요청함, Then 연결된 공유링크 1초 이내 무효화
- **하위 작업**:
  - 1-5-1. 코스 공유 링크 생성 및 개인 저장 시스템
  - 1-5-2. 소유권 기반 저장 기능 (WebSocket 기반)
  - 1-5-3. 좋아요, 댓글, 평가 시스템 로직
  - 1-5-4. 공유 코스 UI/UX 및 소셜 기능 백엔드
  - 1-5-5. 개인 폴더 및 태그 분류 시스템
  - 1-5-6. 코스 공유 테스트 코드 작성
- **참고 문서**: `prd/05-sharing-system.md`, `trd/05-sharing-system.md`

## 2. 사용자 경험 개발 (UX Focus)

### 2-1. 온보딩 (앱) 및 초기 설정 백엔드
- **목표**: 새로운 사용자가 3분 이내 앱에서 첫 번째 코스를 생성할 수 있도록 안내하는 백엔드 시스템
- **완료 정의 (DoD)**:
  - 온보딩 완료율 70% 이상
  - 첫 장소 저장부터 앱 3분 이내
  - 사용자 설정 정보로 개인화 추천 시작
- **수용 기준**:
  - Given 앱 첫 실행, When 온보딩 진행, Then 핵심 저장소 3개의 샘플 표시
  - Given 온보딩 완료, When 첫 코스 추천 시작, Then 설정 기반 개인화 추천 제공
- **하위 작업**:
  - 2-1-1. 온보딩 플로우 상태 스키마 및 로직 ✅ **완료** (2025-09-06)
  - 2-1-2. 사용자 취향 설정 및 사용자 온보딩 시스템 ✅ **완료** (2025-09-06)
  - 2-1-3. 첫 경험을 위한 샘플 및 가이드 제공 ✅ **완료** (2025-09-06)
  - 2-1-4. 온보딩 완료 5단계 및 진척 설정 추적 ✅ **완료** (2025-09-06)
  - 2-1-5. 온보딩 개인화 생성 및 엔지니어링 ✅ **완료** (2025-09-06)
  - 2-1-6. 온보딩 플로우 테스트 코드 작성 ✅ **완료** (2025-09-06)
- **참고 문서**: `prd/06-onboarding-flow.md`, `trd/06-onboarding-flow.md`

### 2-2. 알림 및 개인화 시스템 백엔드
- **목표**: 개인별 관심 사항과 맞춤형 타이밍에 따른 알림을 통해 개인별 사용 빈도 증진
- **완료 정의 (DoD)**:
  - 푸시 알림 전달 95% 정확도
  - 사용자별 알림 선호 설정 및 개인화 기능
  - 알림 데이터와 40% 이상 (앱 재방문 기준)
- **수용 기준**:
  - Given 개인별 선호도, When 18시 추천, Then 맞춤형 알림 전송
  - Given 개인화 설정, When 데이터 분석함, Then 4주 알림 효과 전송 중단
- **하위 작업**:
  - 2-2-1. Firebase FCM 연동 및 푸시 알림 인프라 ✅ **완료** (2025-09-07)
  - 2-2-2. 알림 스케줄링 및 사용자별 타겟팅
  - 2-2-3. 소유권 기반 추천 시간대 (아침, 점심, 저녁시간대) ✅ **완료** (2025-09-07)
  - 2-2-4. 알림 설정 UI 및 개인화 전송 기능 ✅ **완료** (2025-09-07)
  - 2-2-5. 알림 개인화 분석 및 전송 시스템 ✅ **완료** (2025-09-08)
  - 2-2-6. 알림 시스템 테스트 코드 작성 ✅ **완료** (2025-09-08)
- **참고 문서**: `prd/07-notification-system.md`, `trd/07-notification-system.md`

### 2-3. 검색, 필터, 정렬, 기능 백엔드
- **목표**: 광범위한 장소 개인별 데이터에서 개인별 원하는 취향을 3초 이내 찾을 수 있는 고도화된 검색 기능
- **완료 정의 (DoD)**:
  - 검색 응답시간 2초 이내
  - 자동완성 제공 500ms 이내 표시
  - 개인 필터 옵션으로 정확도 높은 결과 전송
- **수용 기준**:
  - Given 키워드 2글자 이상 입력, When 500ms 대기, Then 자동완성 제공 표시
  - Given 검색 필터 개인별 적용, When 검색 실행, Then AND 개인별으로 정확도 높은 결과 제공
- **하위 작업**:
  - 2-3-1. Elasticsearch 기반 검색 인덱스 구축 ✅ **완료** (2025-09-08)
  - 2-3-2. 소유권 자동완성 및 검색 제공 시스템 ✅ **완료** (2025-09-08)
  - 2-3-3. 고급 필터 및 정렬, 5단계 로직 ✅ **완료** (2025-09-11)
  - 2-3-4. 검색 결과 랭킹 및 개인화 엔지니어링 ✅ **완료** (2025-09-11)
  - 2-3-5. 검색 UI/UX 및 성능 최적화 구현 ✅ **완료** (2025-09-14)
  - 2-3-6. 검색 필터 테스트 코드 작성 ✅ **완료** (2025-09-11)
- **참고 문서**: `prd/08-search-filter.md`, `trd/08-search-filter.md`

## 3. 사용자 및 인증 관리 (Authentication & User Management)

### 3-1. Firebase 기반 사용자 시스템 백엔드
- **목표**: 신뢰성이 높은 다양한 로그인 및 인증 방식을 통해 안전한 사용자 시스템 구축
- **완료 정의 (DoD)**:
  - 다양한 로그인 (구글, 애플, 카카오) 연동 완료
  - 인증된 사용자 및 세션 관리 기능
  - 생체 인증 및 보안 검증 5단계
- **수용 기준**:
  - Given 다양한 로그인 선택, When 사용자 인증, Then 5초 이내 로그인 완료
  - Given 인증된 사용자 세션, When 세션 관리, Then 인증된 개인별로 데이터 제공
- **하위 작업**:
  - 3-1-1. Firebase Auth 설정 및 다양한 로그인 구현 ✅ **완료** (2025-09-14)
  - 3-1-2. 인증된 사용자 로직 및 개인별 데이터 연동시스템 ✅ **완료** (2025-09-14)
  - 3-1-3. 생체 인증 및 PIN 인증 시스템
  - 3-1-4. 익명 사용자 및 게스트 개인화 백엔드
  - 3-1-5. 보안 검증 및 데이터별 구현
  - 3-1-6. 사용자 인증 테스트 코드 작성
- **참고 문서**: `prd/09-authentication.md`, `trd/09-authentication.md`

### 3-2. 사용자 프로필 및 설정 관리 백엔드
- **목표**: 사용자별 앱 사용 내역과 맞춤형 사용자가 사용자 첫 정보 제공하는 개인화 설정 전송
- **완료 정의 (DoD)**:
  - 프로필 정보 3초 이내 저장 첫 정보 제공
  - 사용자별 설정 기반 추천 정확도 향상 지표
  - GDPR 준수하는 사용자 정보 관리 기능
- **수용 기준**:
  - Given 프로필 정보 업데이트, When 관리 저장 데이터, Then 3초 이내 소유 앱 정보 정보 표시
  - Given 사용자 정보 삭제 요청, When 24시간 대기, Then 데이터를 개인별 삭제 소유
- **하위 작업**:
  - 3-2-1. 사용자 프로필 관리 시스템 및 데이터별 삭제
  - 3-2-2. 사용자별 설정 및 알림 전송 기능
  - 3-2-3. 사용자 데이터 및 백업 분석 데이터레이어
  - 3-2-4. 사용자 정보 및 개인별 프라이버시 기능
  - 3-2-5. 세션 설정 무효화 및 개인화 시스템
  - 3-2-6. 사용자 프로필 테스트 코드 작성
- **참고 문서**: `prd/10-user-profile.md`, `trd/10-user-profile.md`

## 4. 성능 및 인프라 엔지니어링 (Performance & Infrastructure)

### 4-1. 캐시 및 성능 엔지니어링 시스템 백엔드 ✅ **완료** (2025-01-15)
- **목표**: 대규모 사용자 트래픽에 견딜 수 있는 고성능 캐싱 시스템으로 빠른 인프라 구축
- **완료 정의 (DoD)**:
  - API 응답시간 p95 2초 이내 ✅
  - 캐시 히트율 60% 이상 ✅
  - 동시 사용자 1000명 부하 상황에서 안정성 유지 ✅
- **수용 기준**:
  - Given 캐시 최적화된 개인별, When 캐시 요청, Then 50ms 이내 응답 ✅
  - Given 1000명 동시 접근, When 복합 시뮬레이션, Then 응답시간 증가 없이 서비스 안정성 유지 ✅
- **하위 작업**:
  - 4-1-1. TDD: 다계층 캐시 시스템 테스트 작성 ✅ **완료** (2025-01-15)
  - 4-1-2. Redis 기반 멀티 레벨 캐시 매니저 구현 ✅ **완료** (2025-01-15)
  - 4-1-3. TDD: 성능 모니터링 및 최적화 테스트 작성 ✅ **완료** (2025-01-15)
  - 4-1-4. API 응답 최적화 및 성능 튜닝 대시보드 ✅ **완료** (2025-01-15)
  - 4-1-5. CDN 연동 및 정적 리소스 캐싱 ✅ **완료** (2025-01-15)
  - 4-1-6. 캐시 성능 통합 테스트 및 API 엔드포인트 ✅ **완료** (2025-01-15)
- **참고 문서**: `prd/11-cache-performance.md`, `trd/11-cache-performance.md`

### 4-2. 모니터링 및 로깅 시스템 백엔드 ✅ **완료** (2025-01-15)
- **목표**: 서비스 상태를 실시간 모니터링하고 관측가능성(Observability)을 확보하는 포괄적 모니터링 시스템 구축
- **완료 정의 (DoD)**:
  - 구조화된 로깅 시스템 (JSON format, 민감정보 마스킹) ✅
  - APM 도구 연동 및 성능 지표 모니터링 ✅
  - 사용자 행동 분석 및 대시보드 시스템 ✅
  - 실시간 알림 및 모니터링 셋업 시스템 ✅
  - 서비스 상태 모니터링 및 관리 시스템 ✅
- **수용 기준**:
  - Given 서비스 오류 발생, When 성능 지표 5% 저하, Then 즉시 알림 전송 ✅
  - Given 사용자 액션, When 중요 이벤트 발생, Then 로그 수집 및 분석 완료 ✅
- **하위 작업**:
  - 4-2-1. TDD: 로깅 및 중앙집중식 관리 시스템 테스트 ✅ **완료** (2025-01-15)
  - 4-2-2. 로깅 서비스 구현 (구조화된 로깅, 추적, 로테이션) ✅ **완료** (2025-01-15)
  - 4-2-3. TDD: APM 및 성능 모니터링 테스트 작성 ✅ **완료** (2025-01-15)
  - 4-2-4. APM 서비스 구현 (성능 대시보드, 최적화) ✅ **완료** (2025-01-15)
  - 4-2-5. TDD: 사용자 행동 분석 테스트 작성 ✅ **완료** (2025-01-15)
  - 4-2-6. 사용자 행동 분석 서비스 구현 (추적, 세분화, 대시보드) ✅ **완료** (2025-01-15)
- **참고 문서**: `trd/main.md` (모니터링 요구사항)

## 5. 품질 보장 및 배포 (Quality Assurance & Deployment)

### 5-1. 자동화된 테스트 시스템 (TDD 중심)
- **목표**: TDD 방법론으로 모든 신뢰성 높은 코드 품질 및 버그 방지 시스템
- **완료 정의 (DoD)**:
  - 테스트 커버리지 80% 이상 유지
  - 새로운 기능별 테스트 우선 작성(Test-First) 준수
  - CI/CD 파이프라인에서 모든 테스트 통과 및 배포 자동 검증
- **수용 기준**:
  - Given 새로운 기능 구현, When 코스 추천 샘플, Then 해당하는 테스트 코드 우선 생성
  - Given PR 전송, When CI 파이프라인 실행, Then 모든 테스트 통과를 8분 내에 검증
- **하위 작업**:
  - 5-1-1. TDD 실습으로 및 테스트 사례 정보
  - 5-1-2. 단위 테스트 생성 및 커버리지 관리
  - 5-1-3. 통합 테스트 및 API 테스트 자동화
  - 5-1-4. E2E 테스트 셋업 로직 (사용자 플로우)
  - 5-1-5. 테스트 자동화 및 지속통합 전송
  - 5-1-6. 테스트 프레임워크 테스트 코드 작성
- **참고 문서**: `rules.md` (TDD 가이드라인)

### 5-2. CI/CD 파이프라인 및 배포 자동화 백엔드
- **목표**: 지속적인 배포를 통한 자동화된 파이프라인으로 모든 신뢰성 높은 개발 환경 구축
- **완료 정의 (DoD)**:
  - 코드 병합부터 실서비스 배포까지 자동화
  - 4단계 배포 및 롤백 시스템 구축
  - 스테이징(개발/테스트/실서비스) 설정 관리
- **수용 기준**:
  - Given 코드 병합 8분, When 배포 파이프라인 실행, Then 30분 이내 실서비스 배포 완료
  - Given 배포 후 데이터 전송, When 롤백 구현, Then 5분 이내 데이터소 버전으로 원복
- **하위 작업**:
  - 5-2-1. GitHub Actions 기반 CI/CD 파이프라인 구성
  - 5-2-2. 스테이징 설정 관리 및 툴체인 데이터레이어
  - 5-2-3. Docker 컨테이너화 및 데이터별 알림 자동화
  - 5-2-4. 4단계 배포 및 무중단 시스템
  - 5-2-5. 배포 후 모니터링 및 롤백 자동화
  - 5-2-6. CI/CD 파이프라인 테스트 코드 작성
- **참고 문서**: `trd/main.md` (배포 인프라 요구사항)

---

## 완료 마일스톤 (추가 체크리스트)

### 1차 마일스톤
- [ ] 핵심 5개 기능(링크분석, 장소관리, 코스추천, 지도구현, 공유 시스템) 완료
- [ ] 사용자 인증 및 프로필 관리 시스템 완료
- [ ] 검색/필터 기능으로 사용자 상호작용 향상
- [ ] 테스트 시스템으로 품질 8분의 구현

### 2차 마일스톤
- [ ] API 응답시간 p95 2초 이내 달성
- [ ] 캐시 사용자 1000명 부하 상황에서 안정성 유지
- [ ] 테스트 커버리지 80% 이상 및 TDD 방법론 준수
- [ ] GDPR 준수 사용자 정보 8분 보안 구축

### 3차 마일스톤
- [ ] 모니터링 및 알림 시스템으로 서비스 상태 실시간 구현
- [ ] CI/CD 파이프라인 구축으로 배포 자동화
- [ ] 4단계 배포 및 롤백 시스템 완료
- [ ] 성능 엔지니어링 및 캐시 사례 정보

---

## 추진 일정 및 우선 순위

**Phase 1 (MVP - 8주)**
1. SNS 링크 분석 (1-1)
2. 장소 관리 시스템 (1-2)
3. Firebase 인증 (3-1)
4. 기본 UI/UX 및 온보딩 (2-1)

**Phase 2 (핵심 - 6주)**
5. AI 코스 추천 (1-3)
6. 지도 구현트 (1-4)
7. 알림 시스템 (2-2)
8. 검색/필터 (2-3)

**Phase 3 (고도화 - 4주)**
9. 코스 공유 시스템 (1-5)
10. 사용자 프로필 관리 (3-2)

**Phase 4 (엔지니어링 - 4주)**
11. 성능 엔지니어링 (4-1)
12. 모니터링 시스템 (4-2)
13. CI/CD 및 배포 자동화 (5-2)

---

*작성일: 2025-01-XX*
*작성자: Claude*
*버전: 1.0*
